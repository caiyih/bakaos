## 内核模块详解：内存管理

### 引言

内存管理是操作系统的核心组成部分，它负责在计算机系统中高效、安全地分配和管理内存资源。一个设计良好的内存管理系统对于操作系统的稳定性、性能以及多任务处理能力至关重要。BakaOS 的内存管理系统主要分为三个层面：物理内存管理、虚拟内存管理和内核堆管理。本章将详细阐述这三个层面的设计理念、实现机制及其优缺点。

### 1. 物理内存管理

物理内存管理模块直接与硬件内存打交道，其核心任务是追踪系统中所有可用的物理页帧，并按需进行分配与回收。由`crates/allocation`库提供。

#### 1.1 背景与动机

- 问题阐述： 操作系统内核及其运行的进程都需要使用物理内存。如果没有一个统一的管理器，将会导致内存分配冲突、重复释放、内存泄漏以及严重的内存碎片问题。

- BakaOS 的目标： 使用RAII机制封装低级内存操作，降低了内存错误的风险，又能相对高效地利用物理内存，同时简化内核其他部分对物理内存使用的页帧分配器。

#### 1.2 核心思想与设计

BakaOS 的物理内存管理采用以页帧为基本单位的分配策略，其核心设计思想体现在以下几个方面：

- RAII (Resource Acquisition Is Initialization) 机制的应用：
  
  - 通过 `TrackedFrame` 和 `TrackedFrameRange` 结构体封装单个或连续的物理页帧。这些结构体实现了 `Drop` trait，当它们离开作用域时，其所持有的物理页帧会自动被回收。这种设计将物理页帧的生命周期与 Rust 的所有权系统紧密绑定，极大地简化了内存管理，从机制上防止了内存泄漏。

- 中心化的页帧分配器 (`FrameAllocator`)：
  
  - `FrameAllocator` 负责管理所有的全局物理帧。
  
  - 能够快速分配连续页。
  
  - 通过算法，将回收帧压缩成连续页，优化分配速度。

- 页帧清零 ：
  
  - 为了增强数据安全，防止旧数据通过新分配的页帧泄露，分配器在创建 `TrackedFrame` 时，会通过 `zero_frame` 函数将页帧内容清零。

#### 1.3 优势

- 优势：
  
  - 内存安全与简便性： RAII 机制的运用使得物理内存的分配和回收几乎自动化，显著降低了内存问题的风险，简化了内核其他模块的内存管理逻辑。
  
  - 一定程度的碎片缓解： 通过回收列表和回收时合并相邻空闲块的策略，有助于减少物理内存碎片。
  
  - 安全性增强： 页帧清零功能有助于防止敏感数据泄露。
  
  - 接口清晰： 提供了分配单个、多个（不保证连续）和多个连续页帧的接口，满足不同场景的需求。

### 2. 虚拟内存管理

虚拟内存管理是现代操作系统的基石，它为每个进程提供了一个独立的、连续的地址空间，并负责将这些虚拟地址映射到实际的物理内存页帧上。

#### 2.1 背景与动机

- 解决的核心问题：
  
  - 进程隔离： 防止一个进程访问或破坏另一个进程的内存。
  
  - 地址空间扩展： 允许进程使用比实际物理内存更大的地址空间。
  
  - 内存保护： 控制对内存区域的访问权限（读、写、执行）。
  
  - 简化程序链接与加载： 程序可以假设自己加载到固定的虚拟地址。
  
  - 高效的内存共享： 例如，共享库可以在多个进程间共享同一份物理内存。

- 传统方案对比与BakaOS的思考：
  
  - 一些操作系统（如 rcore 和 xv6 的早期版本）采用跳板页表 (trampoline page table) 的方式，内核和用户空间拥有独立的页表，通过一个特殊的跳板页进行模式切换。这种方式的本质是为了清晰地隔离内核和用户地址空间，避免重叠。
  
  - BakaOS 则借鉴了经典的高半核 (Higher-Half Kernel) 设计思想。我们设想，既然可以将跳板页置于高地址，那么将整个内核都置于高地址也是可行的。这样，内核始终在高虚拟地址运行，可以方便地访问当前进程的用户空间（低地址部分），而无需频繁切换页表或进行分段的内存拷贝。
  
  - 为了让内核能够管理全部物理内存，BakaOS 将虚拟地址空间大致对半分：低地址部分（例如，前256GB）分配给用户空间，高地址部分则用于映射整个物理内存以及内核自身代码和数据。例如，内核可以通过一个固定的偏移量（如 `VIRT_ADDR_OFFSET`，其值为 `0xffff_ffc0_0000_0000` 或 `0x9000_0000_0000_0000`，具体取决于架构）来访问任何物理地址。

#### 2.2 核心思想与设计

BakaOS 的虚拟内存管理围绕以下核心概念构建：

- 高半核内核与统一地址空间 (High-Half Kernel and Unified Address Space):
  
  - 每个进程都使用一套页表结构，该页表同时映射了用户空间的低地址区域和内核空间的高地址区域。
  
  - 内核代码和数据位于高虚拟地址，对所有进程可见（但受权限保护）。
  
  - 当CPU处于内核态时，可以通过 `sstatus` 寄存器的SUM位（Supervisor User Memory access）等机制，直接访问当前进程用户空间的有效虚拟地址。

- 地址空间布局:
  
  启动时的初始页表与向高半核的迁移:
  
  - 面临的挑战： 内核期望在高半虚拟地址运行，但这需要页表支持；而设置页表（如写入RISC-V的`satp`寄存器）的指令本身也需要被CPU执行，此时CPU的程序计数器(PC)通常指向物理地址或简单的低虚拟地址。这是一个典型的“先有鸡还是先有蛋”的问题。
  
  - BakaOS的解决方案——两阶段引导：
    
    1. 阶段一：构建并启用初始页表（在低地址执行）
       
       - 内核启动时，其代码（如 `_start`）在物理地址（例如 `0x80200000`）或一个等效的低虚拟地址执行。
       
       - 在此阶段，内核会构建一个临时的、最小化的初始页表（例如，通过 `platform-abstractions/src/<arch>/boot.rs` 中定义的静态 `PAGE_TABLE` 数组）。这个初始页表至关重要，它必须包含两类关键映射：
         
         - 低地址内核代码映射 (Identity/Temporary Mapping for Boot Code): 将当前正在执行的内核启动代码区域（物理地址 `0x80200000` 附近）映射到一个低虚拟地址（通常是其物理地址本身，即身份映射），并赋予可读可执行(RX)权限。这是为了确保在启用分页机制（例如，写入`satp`）后，CPU仍然能够正确取出并执行紧随其后的、用于跳转到高半核的指令。
           
           - 大页优化： 为了映射这段启动代码，如果使用标准的4KB页面，可能需要创建多级页表结构，反而浪费更多内存（页表本身也占用物理页）。因此，BakaOS倾向于使用一个1GB的大页（Giant Page）来覆盖整个内核早期代码区，这样做既简化了页表设置，也减少了页表自身的内存开销。
         
         - 高半核目标区域映射 (Higher-Half Mappings): 同时，这个初始页表也必须建立起内核最终要运行的高半虚拟地址区域的映射，以及将物理内存映射到高半核的直接映射区。例如，将物理地址 `0x0000_0000` 开始的若干GB（如示例中的前3GB）映射到以 `VIRT_ADDR_OFFSET` 开头的高半虚拟地址。
           
    ```ascii
      // 示例：RISC-V64 启动时的页表项 
      // arr[2] = (0x80000 << 10) | 0xcf; // 物理地址 0x8000_0000 (内核代码区) -> 虚拟地址 0x8000_0000 (1GB 大页)
      // arr[0x100] = (0x00000 << 10) | 0xcf; // 物理地址 0x0000_0000 -> 虚拟地址 VIRT_ADDR_OFFSET + 0x0000_0000 (1GB 大页)
      // arr[0x101] = (0x40000 << 10) | 0xcf; // 物理地址 0x4000_0000 -> 虚拟地址 VIRT_ADDR_OFFSET + 0x4000_0000 (1GB 大页)
      // arr[0x102] = (0x80000 << 10) | 0xcf; // 物理地址 0x8000_0000 -> 虚拟地址 VIRT_ADDR_OFFSET + 0x8000_0000 (1GB 大页)
      // 其中 0xcf (二进制 11001111) 代表 Valid, Readable, Writable, Executable, Global, Accessed, Dirty 等权限。
      // (XXX << 10) 是RISC-V SV39/SV48中将页号转换为PTE物理地址部分（右移12位再左移10位，等效于右移2位）。
    ```

       
       - 启用分页： 将此初始页表的物理基地址写入CPU的页表基址寄存器（如RISC-V的`satp`），并执行必要的TLB刷新指令（如`sfence.vma`）。
    
    2. 阶段二：跳转到高半核虚拟地址（PC仍在低地址，但通过新页表翻译）
       
       - 在分页启用后，CPU的PC仍然指向`satp`写入指令之后的低地址。由于初始页表包含了对这部分低地址内核代码的有效映射，CPU可以继续执行。
       
       - 紧接着的指令是一条绝对跳转指令，其目标地址是内核在高半虚拟地址空间的入口点（如 `_start_virtualized` 函数，其虚拟地址为 `内核物理加载地址 + VIRT_ADDR_OFFSET`）。
       
       - 这个跳转之所以能够成功，是因为初始页表已经预先设置了高半核区域的正确映射。
       
       - 一旦跳转完成，内核就完全在高半虚拟地址空间运行。此时，之前为启动服务的低地址内核代码映射理论上可以被回收或标记为无效（尽管实践中保留以简化页表管理），但高半核对物理内存的直接映射会一直保留，并成为所有后续进程页表的内核部分的标准配置。
  
      这样设计主要目的是让内核能够通过一个统一的、线性的高半虚拟地址视图来直接、高效地访问和管理整个（或大部分）物理内存。这种设计使得内核在管理物理页帧、与硬件MMIO交互、在不同进程间复制数据等操作时非常方便，因为物理地址和内核虚拟地址之间有一个简单的线性转换关系。
  
      我们可以为高位的内核映射添加 S 权限，这样用户程序就无法访问到内核的代码和数据。我们还可以为 `sstatus` 设置 SUM 位，这样内核就可以直接访问用户空间的内存。
  
  - 进程地址空间： 每个用户进程创建时，会复制这份包含内核高半映射的页表结构，并独立映射其用户空间部分（ELF段、栈、堆等）。

- 页表结构 (`PageTable64`, PTE):
  
  - 采用平台相关的多级页表结构（例如，RISC-V SV39 使用三级页表，LoongArch LASX 使用四级页表）。`PageTable64Impl` 是平台无关页表操作的封装。
  
  - 页表项 (PTE) 如 `LA64PageTableEntry` 和 `RV64PageTableEntry` 定义了具体的物理页号和权限位。`GenericMappingFlags` 提供了一套平台无关的权限标志（如Readable, Writable, Executable, User）。

- 用户空间访问安全机制 (`PageGuard`):
  
  - 动机： 虽然高半核设计允许内核直接访问用户虚拟地址，但如果用户传递了一个无效或恶意构造的指针，内核直接解引用可能导致 Page Fault 而崩溃。
  
  - 设计： `PageGuard` 采用 RAII 和 Fluent API 设计模式。在使用用户提供的指针之前，内核代码必须先通过 `PageTable::guard_ptr()` 或 `PageTable::guard_slice()` 等方法创建一个 `PageGuard`。
  
  - 工作流程：
    
    1. `guard_xxx()` 方法会检查目标虚拟地址范围是否在当前页表中有效映射，并且是否满足基本的“用户态可访问”前提。
    
    2. 通过链式调用 `.mustbe_user()`, `.mustbe_readable()`, `.with_write()` 等方法，可以声明预期的访问权限。
    
    3. 如果声明的权限在页表中不满足，`PageGuard` 的创建会失败（返回 `None`）。
    
    4. 如果权限不足，`.with_xxx()` 方法会临时修改页表项以赋予所需权限，并将原始权限记录下来。
    
    5. `PageGuard` 对象在离开作用域时，其 `Drop` 实现（或显式调用 `restore_temporary_modified_pages()`）会恢复对页表项权限的临时修改，并刷新TLB。

#### 2.4 优势与权衡

- 优势：
  
  - 高半核的便利性： 内核代码执行流程相对简单，可以直接通过虚拟地址访问内核数据结构。通过 `sstatus.SUM` 和 `PageGuard` 机制，内核可以方便且相对安全地访问用户空间数据，避免了显式的数据拷贝。
  
  - 简化的地址空间切换： 由于内核和用户共享顶层页表结构（内核部分是共享的），从用户态进入内核态（如系统调用或中断）理论上不需要完整的页表切换，仅需改变权限级别。这可能比完全分离的内核/用户页表方案（如某些使用跳板页的系统）在上下文切换时有更低的TLB开销。
  
  - `PageGuard` 提供的安全性： 极大地减少了因处理用户提供的非法指针而导致的内核崩溃风险，强制开发者在访问用户内存前进行权限检查和声明。

- 工作方向：

  - 高半核的固有安全风险： BakaOS 当前采用的单页表高半核模型，虽然通过 `PageGuard` 保证了直接访问的安全性，但并未完全消除这类微架构层面的风险。即使有页表权限位保护，只要内核页面的映射存在于用户进程的活动页表中，理论上就存在被 Meltdown、Spectre 等侧信道攻击利用的风险，因为这些攻击可能绕过权限检查进行推测执行。
  
  - [Proposal: Secure User/Kernel Isolation via Split Page Tables with Trampoline Support · Issue #42 · caiyih/bakaos · GitHub](https://github.com/caiyih/bakaos/issues/42)，我们已经提出一种设计，将内核部分与用户部分分离，并使用跳板页进行地址空间切换，同时保留高半内核的优势，但是能够防护Meltdown、Spectre 等侧信道攻击利用的风险。

  - TLB 管理：
    
    - 优点： 单一地址空间模型下，用户态到内核态的转换（非页表切换）通常不会导致全局TLB刷写。
    
    - 缺点： 内核映射和用户映射共享TLB条目，可能会增加TLB冲突的概率。`PageGuard` 临时修改权限后需要刷新TLB（`PageTable64Impl::flush_tlb`），这会带来一定的性能开销。
