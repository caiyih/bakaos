# 内核隔离级容器

## 背景：运行环境隔离的意义

在多用户、多任务的计算环境中，隔离不同运行环境的目的是防止资源干扰和安全风险。
在云计算、容器化平台和多租户环境中，这种隔离显得尤为重要，因为不同的应用或用户可能需要运行在彼此完全独立的系统视图中。

传统做法（如 Linux 的 namespace）会通过内核机制，在单一内核实例中隔离不同的资源视图，例如进程表、网络接口、文件系统挂载点等。这种方法已经非常成熟，但在灵活性、测试便利性和资源控制粒度方面仍有一定限制。

## BakaEx 的实现：隔离的 IKernel 实例

BakaEx 通过 **依赖注入** 实现**有界上下文**。它们通过将其分解为单独的概念模块，为大型应用程序或组织提供一种解决复杂性的方法。 然后，每个概念模块表示一个上下文，该上下文与其他上下文（因此，边界）分离，并且可以独立发展。

在 BakaEx 中，系统调用的处理过程就是这样一个上下文。其核心是一个 ITask 实例和一个 IKernel 实例（在本项目的[依赖注入](./dependency.md)中有详细介绍）。前者用于限定上下文中的目标任务，而后者则是我们实现内核隔离的关键。

本系统在架构上引入了一个核心概念——**IKernel**，它是所有内核功能的依赖接口集合。
所有关键的内核组件，例如：

- 文件系统树
- 调度器队列
- 内存分配器
- IPC 通信队列

都不是全局固定的，而是作为依赖注入到 IKernel 中。

在处理一个系统调用或请求时，内核逻辑只依赖于当前请求上下文所绑定的 IKernel 实例，而不会访问全局状态。这意味着：
只要创建一个新的 IKernel 实例，就等于启动了一个全新的、彼此隔离的内核运行环境。

## 创建隔离环境的过程

创建隔离环境的过程非常简单：

1. 构造一个新的 IKernel 实例，并为它注入一套全新的依赖（独立的文件系统、调度器、内存分配器等）。
2. 将该实例绑定到要运行的任务或测试上下文中。
3. 所有在该上下文中发生的系统调用，都只会访问该 IKernel 内部的资源，不会影响其他 IKernel 实例。

这种设计让隔离环境的生命周期、资源初始化方式以及清理过程都由开发者完全掌控，无需修改全局状态或重启内核。

## 动态可调整的隔离机制

传统的内核隔离机制（如 Linux namespace 或虚拟机）在创建时就固定了隔离边界，一旦运行，变更隔离状态会非常困难，甚至需要重启或迁移整个环境。而本系统的设计，将隔离环境抽象为 IKernel 实例，并且让每个进程的内核依赖都可以在运行时替换。这带来了前所未有的灵活性。

### 将进程移动到其他隔离环境

每个进程只与当前绑定的 IKernel 实例交互，因此只要替换该进程的 IKernel 引用，就能让它“无缝”切换到另一个隔离环境中。

这种切换过程无需重新创建进程，也不需要通过网络或文件迁移数据，所有状态仍然保留，只是底层访问的资源集合发生了变化。这在多租户环境、资源调度和负载均衡中有重要意义，可以在不打断业务的情况下进行环境迁移。

### 合并与分隔隔离环境

由于 IKernel 实例是完全独立的对象，我们可以在运行时将多个隔离环境的资源合并到同一个 IKernel 中，实现环境合并；也可以将原有的 IKernel 中部分资源拆分出来，生成新的 IKernel 实例，实现环境分隔。

这种能力让隔离环境不再是静态边界，而变成可以动态重构的运行单元，非常适合需要灵活调整租户边界、按需扩缩容的云平台。

### 替换和修改隔离环境的依赖

IKernel 内部的每个依赖（如文件系统、调度器、内存分配器、IPC 队列等）都是通过依赖注入管理的，这意味着我们可以在运行时替换这些依赖的实现。

例如：

- 将某个隔离环境的文件系统从本地存储替换为分布式存储
- 将调度器替换为支持实时优先级的实现
- 在不中断进程的情况下，调整 IPC 队列策略

这种机制让隔离环境的功能和性能可以随业务需求动态变化，而不必进行大规模停机或迁移。

## 与 Linux namespace 的比较

Linux namespace 在单一内核实例中实现隔离，虽然高效，但在以下方面存在限制：

- **灵活性**：namespace 的隔离粒度固定，例如 PID namespace、mount namespace 等，组合方式受到内核实现的限制。
- **可移植性**：namespace 功能依赖内核版本与配置，非所有环境都能直接使用。

相比之下，本系统的设计更加灵活：

- 每个 IKernel 实例的依赖组合**完全自定义**，不受固定隔离类型的限制。这意味着你可以选择一部分资源进行隔离，另一部分不隔离。
- 不依赖宿主内核的特性，即使在不支持 namespace 的平台上也能创建隔离环境。
- 在单元测试中，只需实例化一个 TestKernel，就能得到一个完全隔离的运行环境，允许测试**并行执行**且互不干扰。

## 在云计算中的价值

在云计算场景中，运行环境的隔离是基础需求。
本设计可以在不牺牲性能的前提下，实现高度灵活的隔离：

- 每个租户、容器或虚拟应用可以绑定到自己独立的 IKernel 实例。
- 隔离不仅限于文件系统或网络，还可根据业务需求扩展到任何内核功能模块。
- 支持快速创建和销毁运行环境，适合动态伸缩、短生命周期的云原生工作负载。

这种设计将隔离机制从“内核功能之一”提升为“内核运行时的基本构造单元”，让隔离变得像创建对象一样简单而高效。

## 总结

通过依赖注入与 IKernel 实例化机制，本系统能够轻易创建内核级别隔离的运行环境，不仅能用于云计算生产环境，也能为测试与研发提供无与伦比的灵活性与便利性。这种动态可调整的隔离机制让内核隔离不仅仅是安全和资源控制的手段，更是一个灵活可编排的运行时平台。它将传统静态隔离提升为动态可管理、可优化、可重构的资源管理模型，为云计算、多租户系统和高可用架构带来了极大的设计自由度。

相较于 Linux namespace，这种方法在隔离粒度、可移植性和扩展性上都有明显优势，是一种将隔离理念与现代软件工程方法深度结合的创新方案。
