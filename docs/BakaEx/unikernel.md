# BakaEx —— Unikernel 的超集

## 背景：传统内核中的系统调用机制

在传统的操作系统中，用户程序与内核之间隔离在不同的特权级中。当用户程序需要访问操作系统服务（如文件读写、内存映射、进程创建等）时，必须通过“系统调用”来进入内核态。这一过程一般分为三个阶段：

- **陷入（Trap）**：用户程序执行特定的指令（如 `syscall` 或 `ecall`），引发一个受控异常，CPU 切换到内核态。
- **陷入处理（Trap Handler）**：内核通过一个统一入口处理器读取系统调用编号、参数，并跳转到对应的系统调用处理函数。
- **返回（Return from Trap）**：系统调用完成后，恢复用户程序上下文，返回用户态并将结果传回。

这种机制是现代多任务操作系统的基础，它通过硬件和软件的配合，实现了用户态和内核态之间的隔离与安全保护。

### 什么是 Unikernel？

Unikernel 是一种极简化的操作系统架构，它将**应用程序、运行时库和必要的操作系统服务**编译为单个定制化镜像，运行在单地址空间且无特权级切换的环境中。与传统操作系统不同：

- **无用户态/内核态分离**：应用与内核服务在同一特权级（通常是 Ring 0）运行
- **单地址空间**：消除传统进程隔离，所有代码共享同一内存空间
- **垂直优化**：仅包含应用实际需要的驱动和服务（如仅需 TCP 栈时排除文件系统）
- **直接硬件访问**：通过 LibOS 模式直接操作硬件，或作为虚拟机镜像运行

其核心价值在于：

- **极致性能**：系统调用开销趋近于零
- **极简攻击面**：裁剪无关组件提升安全性
- **低资源占用**：镜像可小至数十 KB

### Unikernel 中的系统调用实现

在 Unikernel 架构下，传统系统调用被彻底重构：

| **传统内核**              | **Unikernel**                |
| ------------------------- | ---------------------------- |
| 通过 `syscall` 指令陷入   | **直接函数调用**             |
| 用户态 → 内核态上下文切换 | **无上下文切换**             |
| 参数经寄存器/栈传递       | **参数作为普通函数参数传递** |
| 处理器查表跳转            | **静态链接直接寻址**         |

具体实现形式：

```rust
// Unikernel 中的"系统调用"实质是内部函数
fn sys_write(fd: usize, buf: &[u8]) -> Result<usize, SysError> {
    // 直接的系统调用函数
}

// 应用代码直接调用
let data = b"Hello Unikernel";
sys_write(STDOUT, data).unwrap(); // 直接进入上面的函数
```

## 本设计的核心理念：系统调用等价于普通函数调用

在本系统设计中，整个系统被高度模块化，并允许系统调用逻辑在用户态测试中直接以“普通函数”的形式运行。简而言之：

**我们将“syscall trap → handler”的过程，等价地降级为“函数调用”。**

这并不是简单的模拟，而是结构性重构。我们将原本由陷入处理器完成的工作，抽象为接口，再将真正的“系统调用处理逻辑”完全移出 trap handler，封装为普通函数。其关键特征包括：

- 系统调用参数通过普通 Rust 函数参数传入，而非通过寄存器或用户栈。
- 不依赖硬件陷入机制或上下文切换，完全可在用户态环境中运行。
- 返回值通过函数返回语义传出，无需手动恢复上下文。

下图展示了我们内核的原理：

![系统调用](./assets/syscall.png)

## 降级的正确性与等价性

这种“降级”并不是功能上的退化，而是一种语义保持、形式简化的转换。在内核实际运行时：

- 真正的 `syscall` 指令仍然由用户程序执行，陷入处理器将系统调用编号、参数解析后，转发给对应的系统调用实现函数。
- 在测试环境中，则不需要陷入过程，直接调用系统调用函数本身即可。

也就是说，**trap handler 本质上只是一个调度器，它将不同编号的系统调用映射到对应的函数**。一旦这一层被抽象化，我们就可以在测试环境中绕过 trap 机制，直接调用目标函数，而不影响语义和行为。

## 与 Unikernel 的关系

Unikernel 是一种将操作系统功能“链接”进应用程序中的架构。它通常只包含一个应用程序和该程序所需的最少内核组件，并直接运行在裸机或轻量虚拟机上。其核心优势是：

- 无需用户态和内核态切换，提升性能。
- 应用程序与操作系统深度融合，提升安全性与定制性。

本系统的设计理念在架构上是对 Unikernel 的**泛化和提升**，因为：

- 在测试与开发环境中，本系统将内核视作库，系统调用作为函数，**行为上等价于一个用户态可测试的 Unikernel**。
- 与典型 Unikernel 相比，本系统仍保留完整的用户空间、内核空间、页表管理等机制，因此可平滑运行于传统的多任务内核环境中。
- 所有内核子模块都可以独立调用、测试、组合，从而构成一个更加模块化、可重用的系统架构。

可以说，本系统在不牺牲完整性与通用性的前提下，达成了 Unikernel 所追求的“极简调用路径”与“无陷入开销”的效果。

## 实践效果：统一的实现，多环境复用

在本设计中，系统调用实现的唯一性是一个显著优势：

- 无需编写一套“测试用的系统调用实现”，再另写一套“真实内核中的实现”，而是使用**完全一致的代码**。
- 在真实内核中，这些实现被 trap handler 调用；
- 在测试环境中，它们被作为普通函数调用；

这种统一极大降低了代码冗余，减少了 bug 源，提升了维护性。

## 对开发者的意义：统一模型、降低复杂度

将系统调用设计为普通函数调用的方式，极大地简化了以下方面：

- **调试**：开发者可以像调试普通函数一样调试系统调用，无需设置陷入断点或切换调试上下文。
- **测试**：每个系统调用都可以单独被测试，在 CI 中运行，无需构建镜像或启动内核。
- **重用**：系统调用代码可以在实际内核中使用，也可以在仿真、测试、Unikernel 等不同环境中重用。
- **拓展性**：更容易为每个调用增加监控、审计、日志、权限检查等附加功能。

这种高度一致性和灵活性，远超传统操作系统中的系统调用处理模型。

## 对教学与研究的价值

本系统设计为教学与研究带来了前所未有的便利性：

- 学生可以在普通操作系统中学习和实验内核行为，无需复杂的搭建环境。
- 教学案例可将系统调用拆分为最小测试单元，每个系统调用行为可独立验证。
- 研究者可以快速验证新的调度算法、内存分配策略或页表机制，而无需编写完整的内核。

这种设计理念为现代操作系统开发打开了一种新的范式：**将内核作为库，将系统调用作为函数，从而将开发过程彻底融入现代软件工程流程中**。

## 总结：Unikernel 范式的升华

BakaEx 通过将系统调用抽象为**可插拔的函数接口**，实现了：

- **性能与安全的弹性平衡**：运行时在零开销调用与硬件隔离间动态权衡
- **开发范式统一**：从单元测试到生产部署使用同一代码路径

通过将系统调用陷入流程转化为普通函数调用，本系统打破了传统内核中用户态与内核态的障碍，实现了系统调用可在用户态测试、调试、组合的能力。其架构既包含了 Unikernel 的高性能路径，又保留了多任务通用操作系统的灵活性和扩展性。通过保持语义一致性与行为可验证性，这种设计实现了“开发友好”与“系统完整性”的统一，这种设计不仅继承了 Unikernel 的性能优势，更通过巧妙的抽象化解了其安全隔离和可测试性困境，是一个真正意义上的通用可测试内核架构的探索与实践。
