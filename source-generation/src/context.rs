use std::collections::HashSet;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

use crate::SourceGenerationError;
use crate::module::{ExportSymbol, SymbolExportType, SymbolExportTypeDiscriminant};

pub const GENERATED_CODE_HEADER_FULL: &str =
    "// @generated by BakaOS/source-generation - DO NOT EDIT";

pub const GENERATED_CODE_HEADER_SHORT: &str = "// @generated";

pub struct SourceGenerationContext {
    generated_sources: HashSet<String>,
    code_generation_directory: PathBuf,
    mod_exports: Vec<ExportSymbol>,
    registered_symbol_keys: HashSet<(Vec<String>, SymbolExportTypeDiscriminant)>,
    supress_all_lint_warnings: bool,
}

impl SourceGenerationContext {
    pub fn new(code_generation_directory: PathBuf, supress_lint: bool) -> Self {
        Self {
            generated_sources: HashSet::new(),
            code_generation_directory,
            mod_exports: Vec::new(),
            registered_symbol_keys: HashSet::new(),
            supress_all_lint_warnings: supress_lint,
        }
    }

    fn is_generated_file(&self, code_text: &str) -> bool {
        code_text
            .trim_start_matches(['\n', '\r', '\t', ' '])
            .split('\n')
            .map(|line| line.trim())
            .filter(|line| !line.is_empty())
            .take_while(|line| line.starts_with("//"))
            .any(|line| line.starts_with(GENERATED_CODE_HEADER_SHORT))
    }

    pub fn add_source(
        &mut self,
        file_path: &str,
        source_text: &str,
        overwrite_non_generated: bool,
        overwrite_generated: bool,
    ) -> Result<(), SourceGenerationError> {
        if Path::new(file_path).is_absolute() {
            return Err(SourceGenerationError::CodeFileCanNotBeAbsolutePath);
        }

        if Path::new(file_path).components().count() > 1 {
            return Err(SourceGenerationError::NestedSymbolGenerationNotSupported);
        }

        let full_path = self.code_generation_directory.join(file_path);

        if full_path.exists() {
            let contents = fs::read_to_string(&full_path)?;
            let is_generated = self.is_generated_file(&contents);

            if self.generated_sources.contains(file_path) {
                return Err(SourceGenerationError::CodeFileAlreadyGenerated);
            } else if (is_generated && !overwrite_generated)
                || !is_generated && !overwrite_non_generated
            {
                return Err(SourceGenerationError::CodeFileExists);
            }
        } else if let Some(parent_dir) = full_path.parent() {
            fs::create_dir_all(parent_dir)?;
        }

        self.generated_sources.insert(file_path.to_string());

        let mut final_content = format!("{}\n\n{}", GENERATED_CODE_HEADER_FULL, source_text);

        // FIXME: handing CRLF
        if !final_content.ends_with('\n') {
            final_content.push('\n');
        }

        let mut file = fs::File::create(full_path)?;
        file.write_all(final_content.as_bytes())?;
        Ok(())
    }

    pub fn register_export_symbol(
        &mut self,
        symbol: &str,
        export_type: SymbolExportType,
        public: bool,
    ) -> Result<(), SourceGenerationError> {
        let path: Vec<String> = symbol.split("::").map(|s| s.to_string()).collect();
        let key = (path.clone(), export_type.kind());

        if self.registered_symbol_keys.contains(&key) {
            return Err(SourceGenerationError::SymbolAlreadyRegistered);
        }

        self.registered_symbol_keys.insert(key);

        self.mod_exports.push(ExportSymbol {
            path,
            export_type,
            public,
        });

        Ok(())
    }

    pub fn generate_mod_rs(&self) -> Result<(), SourceGenerationError> {
        let mut lines = Vec::new();
        let mut declared_mods = HashSet::new();

        for export in &self.mod_exports {
            let top_level = export.path.first().unwrap().to_string();

            match &export.export_type {
                SymbolExportType::Mod => {
                    if declared_mods.insert(top_level.clone()) {
                        let mut line = String::new();
                        if self.supress_all_lint_warnings {
                            line.push_str("#[rustfmt::skip]\n");
                        }
                        line.push_str(&format!(
                            "{}mod {};",
                            if export.public { "pub " } else { "" },
                            top_level
                        ));
                        lines.push(line);
                    }
                }
                SymbolExportType::Use { as_name } => {
                    if declared_mods.insert(top_level.clone()) {
                        let mut mod_line = String::new();
                        if self.supress_all_lint_warnings {
                            mod_line.push_str("#[rustfmt::skip]\n");
                        }
                        mod_line.push_str(&format!("mod {};", top_level));
                        lines.push(mod_line);
                    }

                    let mut use_line = String::new();
                    if self.supress_all_lint_warnings {
                        use_line.push_str("#[rustfmt::skip]\n");
                    }

                    let path_str = export.path.join("::");
                    let rename = if let Some(name) = as_name {
                        format!(" as {}", name)
                    } else {
                        String::new()
                    };

                    use_line.push_str(&format!(
                        "{}use crate::generated::{}{};",
                        if export.public { "pub " } else { "" },
                        path_str,
                        rename
                    ));

                    lines.push(use_line);
                }
            }
        }

        // FIXME: handing CRLF
        let content = format!("{}\n\n{}\n", GENERATED_CODE_HEADER_FULL, lines.join("\n"));

        let mod_rs_path = self.code_generation_directory.join("mod.rs");
        fs::write(mod_rs_path, content)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn test_generate_new_file_successfully() {
        let dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let result = ctx.add_source("test.rs", "pub fn hello() {}", false, false);
        assert!(result.is_ok());

        let file_content = fs::read_to_string(dir.path().join("test.rs")).unwrap();
        assert!(file_content.contains(GENERATED_CODE_HEADER_FULL));
        assert!(file_content.contains("pub fn hello()"));
    }

    #[test]
    fn test_absolute_path_rejected() {
        let dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let result = ctx.add_source("/absolute/path.rs", "fn x() {}", false, false);
        assert_eq!(
            result,
            Err(SourceGenerationError::CodeFileCanNotBeAbsolutePath)
        );
    }

    #[test]
    fn test_non_generated_file_no_overwrite() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("test.rs");
        fs::write(&file_path, "fn non_generated() {}").unwrap();

        let mut ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let result = ctx.add_source("test.rs", "pub fn new_fn() {}", false, false);
        assert_eq!(result, Err(SourceGenerationError::CodeFileExists));
    }

    #[test]
    fn test_generated_file_overwrite_allowed() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("test.rs");
        fs::write(
            &file_path,
            format!(
                "{}\nfn old_generated_code() {{}}",
                GENERATED_CODE_HEADER_SHORT
            ),
        )
        .unwrap();

        let mut ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let result = ctx.add_source("test.rs", "pub fn new_fn() {}", false, true);
        assert!(result.is_ok());

        let new_content = fs::read_to_string(file_path).unwrap();
        assert!(new_content.contains("pub fn new_fn()"));
    }

    #[test]
    fn test_generated_file_no_overwrite_if_flag_is_false() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("test.rs");
        fs::write(
            &file_path,
            format!("{}\nfn generated() {{}}", GENERATED_CODE_HEADER_SHORT),
        )
        .unwrap();

        let mut ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let result = ctx.add_source("test.rs", "pub fn updated() {}", false, false);
        assert_eq!(result, Err(SourceGenerationError::CodeFileExists));
    }

    #[test]
    fn test_already_generated_file_error() {
        let dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        ctx.add_source("dup.rs", "fn a() {}", false, true).unwrap();
        let result = ctx.add_source("dup.rs", "fn b() {}", false, true);

        assert_eq!(result, Err(SourceGenerationError::CodeFileAlreadyGenerated));
    }

    #[test]
    fn test_is_generated_file_detects_comment_header() {
        let dir = tempdir().unwrap();
        let ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let code = format!(
            "{}\n// more comments\n\nfn something() {{}}",
            GENERATED_CODE_HEADER_SHORT
        );
        assert!(ctx.is_generated_file(&code));
    }

    #[test]
    fn test_is_generated_file_false_when_missing_header() {
        let dir = tempdir().unwrap();
        let ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let code = "// just a comment\nfn something() {}";
        assert!(!ctx.is_generated_file(code));
    }

    #[test]
    fn test_generate_into_subdirectory() {
        let dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let result = ctx.add_source("subdir/test.rs", "fn inside() {}", false, false);
        assert_eq!(
            result,
            Err(SourceGenerationError::NestedSymbolGenerationNotSupported)
        );
    }

    #[test]
    fn test_generated_header_with_leading_whitespace_and_newlines() {
        let dir = tempdir().unwrap();
        let ctx = SourceGenerationContext::new(dir.path().to_path_buf(), false);

        let code = format!("\n\n\t  {}\nfn x() {{}}", GENERATED_CODE_HEADER_SHORT);
        assert!(ctx.is_generated_file(&code));
    }

    #[test]
    fn test_add_source_rejects_nested_path() {
        let tmp_dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(tmp_dir.path().to_path_buf(), false);

        let result = ctx.add_source("nested/foo.rs", "fn bar() {}", false, false);

        assert_eq!(
            result,
            Err(SourceGenerationError::NestedSymbolGenerationNotSupported)
        );
    }

    #[test]
    fn test_add_source_rejects_absolute_path() {
        let tmp_dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(tmp_dir.path().to_path_buf(), false);

        let result = ctx.add_source("/absolute/path.rs", "fn bar() {}", false, false);

        assert_eq!(
            result,
            Err(SourceGenerationError::CodeFileCanNotBeAbsolutePath)
        );
    }
}

#[cfg(test)]
mod tests_module {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    fn read_mod_rs(path: &Path) -> String {
        fs::read_to_string(path.join("mod.rs")).unwrap()
    }

    #[test]
    fn test_generate_mod_rs_basic() {
        let tmp_dir = tempdir().unwrap();
        let gen_dir = tmp_dir.path().join("generated");
        fs::create_dir_all(&gen_dir).unwrap();

        let mut ctx = SourceGenerationContext::new(gen_dir.clone(), false);

        ctx.register_export_symbol("api".into(), SymbolExportType::Mod, true)
            .unwrap();

        ctx.register_export_symbol(
            "api::v1".into(),
            SymbolExportType::Use { as_name: None },
            true,
        )
        .unwrap();

        ctx.register_export_symbol(
            "api::internal".into(),
            SymbolExportType::Use {
                as_name: Some("internal_api".into()),
            },
            false,
        )
        .unwrap();

        ctx.generate_mod_rs().unwrap();

        let content = read_mod_rs(&gen_dir);

        let expected = format!(
            r"{header}

pub mod api;
pub use crate::generated::api::v1;
use crate::generated::api::internal as internal_api;",
            header = GENERATED_CODE_HEADER_FULL
        );

        assert_eq!(
            content.trim(),
            expected.trim(),
            "Generated mod.rs does not match expected"
        );
    }

    #[test]
    fn test_generate_mod_rs_order_is_preserved() {
        let tmp_dir = tempdir().unwrap();
        let gen_dir = tmp_dir.path().join("generated");
        fs::create_dir_all(&gen_dir).unwrap();

        let mut ctx = SourceGenerationContext::new(gen_dir.clone(), false);

        ctx.register_export_symbol("zeta".into(), SymbolExportType::Mod, true)
            .unwrap();
        ctx.register_export_symbol("alpha".into(), SymbolExportType::Mod, true)
            .unwrap();
        ctx.register_export_symbol("beta".into(), SymbolExportType::Use { as_name: None }, true)
            .unwrap();
        ctx.register_export_symbol(
            "gamma".into(),
            SymbolExportType::Use {
                as_name: Some("g".into()),
            },
            false,
        )
        .unwrap();

        ctx.generate_mod_rs().unwrap();

        let content = read_mod_rs(&gen_dir);

        let expected = format!(
            r"{header}
        
pub mod zeta;
pub mod alpha;
mod beta;
pub use crate::generated::beta;
mod gamma;
use crate::generated::gamma as g;",
            header = GENERATED_CODE_HEADER_FULL
        );

        // We compare line-by-line to verify order
        let actual_lines: Vec<_> = content.lines().filter(|l| !l.trim().is_empty()).collect();
        let expected_lines: Vec<_> = expected.lines().filter(|l| !l.trim().is_empty()).collect();

        assert_eq!(
            actual_lines, expected_lines,
            "Line-by-line comparison failed"
        );
    }

    #[test]
    fn test_duplicate_symbol_registration_fails_on_same_type() {
        let tmp_dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(tmp_dir.path().to_path_buf(), false);

        ctx.register_export_symbol("dup".into(), SymbolExportType::Mod, true)
            .unwrap();

        let result = ctx.register_export_symbol("dup".into(), SymbolExportType::Mod, true);
        assert_eq!(result, Err(SourceGenerationError::SymbolAlreadyRegistered));
    }

    #[test]
    fn test_duplicate_symbol_registration_allows_different_types() {
        let tmp_dir = tempdir().unwrap();
        let mut ctx = SourceGenerationContext::new(tmp_dir.path().to_path_buf(), false);

        ctx.register_export_symbol("same".into(), SymbolExportType::Mod, true)
            .unwrap();

        // different type (Use instead of Mod)
        let result = ctx.register_export_symbol(
            "same".into(),
            SymbolExportType::Use { as_name: None },
            true,
        );
        assert!(result.is_ok());
    }

    #[test]
    fn test_generate_mod_rs_infers_mod_from_use() {
        let tmp_dir = tempdir().unwrap();
        let gen_dir = tmp_dir.path().join("generated");
        fs::create_dir_all(&gen_dir).unwrap();

        let mut ctx = SourceGenerationContext::new(gen_dir.clone(), false);

        // No explicit "mod", only "use"
        ctx.register_export_symbol("api".into(), SymbolExportType::Use { as_name: None }, true)
            .unwrap();

        ctx.generate_mod_rs().unwrap();
        let content = fs::read_to_string(gen_dir.join("mod.rs")).unwrap();

        assert!(content.contains("mod api;"));
        assert!(content.contains("pub use crate::generated::api;"));
    }
}

#[cfg(test)]
mod tests_supress_lint {
    use std::fs;

    use tempfile::tempdir;

    use crate::{SourceGenerationContext, SymbolExportType};

    #[test]
    fn test_generate_mod_rs_with_rustfmt_skip_enabled() {
        let tmp_dir = tempdir().unwrap();
        let gen_dir = tmp_dir.path().join("generated");
        fs::create_dir_all(&gen_dir).unwrap();

        let mut ctx = SourceGenerationContext::new(gen_dir.clone(), true); // enable lint suppression

        ctx.register_export_symbol("internal".into(), SymbolExportType::Mod, false)
            .unwrap();
        ctx.register_export_symbol("api".into(), SymbolExportType::Mod, true)
            .unwrap();
        ctx.register_export_symbol(
            "internal::helper".into(),
            SymbolExportType::Use {
                as_name: Some("helper".into()),
            },
            false,
        )
        .unwrap();

        ctx.generate_mod_rs().unwrap();

        let mod_rs = fs::read_to_string(gen_dir.join("mod.rs")).unwrap();
        assert!(mod_rs.contains("#[rustfmt::skip]\nmod internal;"));
        assert!(mod_rs.contains("#[rustfmt::skip]\npub mod api;"));
        assert!(
            mod_rs.contains("#[rustfmt::skip]\nuse crate::generated::internal::helper as helper;")
        );
    }
}
